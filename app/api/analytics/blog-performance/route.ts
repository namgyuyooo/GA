import { NextRequest, NextResponse } from 'next/server'
import { google } from 'googleapis'
import { JWT } from 'google-auth-library'
import * as fs from 'fs'
import * as path from 'path'

interface BlogPostPerformance {
  title: string
  pagePath: string
  pageViews: number
  avgSessionDuration: number
  bounceRate: number
  conversions: number
  revenue: number
  keywords: string[]
  recommendations: string[]
  category: string // Added category
}

// GA4에서 데이터 가져오기
async function fetchDataFromGA4(propertyId: string, period: string) {
  const serviceAccountPath = path.join(process.cwd(), 'secrets/ga-auto-464002-672370fda082.json')
  const serviceAccountData = fs.readFileSync(serviceAccountPath, 'utf8')
  const serviceAccount = JSON.parse(serviceAccountData)

  const jwtClient = new JWT({
    email: serviceAccount.client_email,
    key: serviceAccount.private_key,
    scopes: ['https://www.googleapis.com/auth/analytics.readonly'],
  })

  const analyticsDataClient = google.analyticsdata({
    version: 'v1beta',
    auth: jwtClient,
  })

  const [startDate, endDate] = period.includes('daysAgo')
    ? [period, 'today']
    : ['2023-01-01', 'today'] // Fallback for custom date ranges

  const response = await analyticsDataClient.properties.runReport({
    property: `properties/${propertyId}`,
    requestBody: {
      dateRanges: [
        {
          startDate: startDate,
          endDate: endDate,
        },
      ],
      dimensions: [
        { name: 'pagePath' },
        { name: 'pageTitle' },
        { name: 'sessionSource' }, // For keywords
        { name: 'sessionMedium' }, // For keywords
        { name: 'unifiedScreenName' }, // For blog post titles
      ],
      metrics: [
        { name: 'screenPageViews' },
        { name: 'averageSessionDuration' },
        { name: 'bounceRate' },
        { name: 'conversions' },
        { name: 'totalRevenue' },
      ],
      dimensionFilter: {
        orGroup: {
          expressionBuilders: [
            {
              filter: {
                fieldName: 'pagePath',
                stringFilter: { matchType: 'CONTAINS', value: '/blog/' },
              },
            },
            {
              filter: {
                fieldName: 'pagePath',
                stringFilter: { matchType: 'CONTAINS', value: '/success-stories/' },
              },
            },
            {
              filter: {
                fieldName: 'pagePath',
                stringFilter: { matchType: 'CONTAINS', value: '/news/' },
              },
            },
          ],
        },
      },
      orderBys: [{ metric: { metricName: 'screenPageViews' }, desc: true }],
      limit: 1000,
    },
  })

  return response.data.rows || []
}

// 페이지 경로 분류
function classifyPagePath(pagePath: string): string {
  if (pagePath.startsWith('/success-stories/')) {
    return 'success-stories'
  } else if (pagePath.startsWith('/blog/')) {
    return 'blog'
  } else if (pagePath.startsWith('/news/')) {
    return 'news'
  } else {
    return 'other'
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const propertyId = searchParams.get('propertyId') || '464147982' // Default property ID
    const period = searchParams.get('period') || '30daysAgo'

    const ga4Data = await fetchDataFromGA4(propertyId, period)

    const blogPerformanceMap = new Map<string, BlogPostPerformance>()

    ga4Data.forEach((row: any) => {
      const pagePath = row.dimensionValues[0].value
      const pageTitle = row.dimensionValues[1].value
      const sessionSource = row.dimensionValues[2].value
      const sessionMedium = row.dimensionValues[3].value
      const unifiedScreenName = row.dimensionValues[4].value

      const pageViews = parseFloat(row.metricValues[0].value)
      const avgSessionDuration = parseFloat(row.metricValues[1].value)
      const bounceRate = parseFloat(row.metricValues[2].value)
      const conversions = parseFloat(row.metricValues[3].value)
      const revenue = parseFloat(row.metricValues[4].value)

      const category = classifyPagePath(pagePath)

      if (!blogPerformanceMap.has(pagePath)) {
        blogPerformanceMap.set(pagePath, {
          title: unifiedScreenName || pageTitle || pagePath,
          pagePath,
          pageViews: 0,
          avgSessionDuration: 0,
          bounceRate: 0,
          conversions: 0,
          revenue: 0,
          keywords: [], // To be populated from GSC or other sources
          recommendations: [], // To be generated by AI
          category,
        })
      }

      const currentData = blogPerformanceMap.get(pagePath)!
      currentData.pageViews += pageViews
      currentData.avgSessionDuration += avgSessionDuration // This needs to be averaged later
      currentData.bounceRate += bounceRate // This needs to be averaged later
      currentData.conversions += conversions
      currentData.revenue += revenue

      // Simple keyword extraction (can be improved)
      if (sessionSource === 'google' && sessionMedium === 'organic' && unifiedScreenName) {
        currentData.keywords.push(unifiedScreenName)
      }
    })

    // Calculate averages for duration and bounce rate
    const finalBlogPosts = Array.from(blogPerformanceMap.values()).map((post) => ({
      ...post,
      avgSessionDuration: post.pageViews > 0 ? post.avgSessionDuration / post.pageViews : 0,
      bounceRate: post.pageViews > 0 ? post.bounceRate / post.pageViews : 0,
      keywords: Array.from(new Set(post.keywords)), // Remove duplicates
    }))

    return NextResponse.json({
      success: true,
      data: finalBlogPosts,
      message: '블로그 성과 데이터 로드 완료',
    })
  } catch (error: any) {
    console.error('Blog performance API error:', error)
    return NextResponse.json(
      {
        success: false,
        message: 'Failed to fetch blog performance data',
        details: error.message,
      },
      { status: 500 }
    )
  }
}
